    - Учебник от microsoft - https://docs.microsoft.com/ru-ru/visualstudio/docker/tutorials/docker-tutorial
    - Видео на youtub - docker+flask for data science
1. создаем файл Dockerfile указывается с какого образа создается контейнер
    FROM python: 3.8

2. создаем файл docker-compose.yml для определения служб и с помощью одной команды запускать и останавливать все, что нужно.
    https://docs.docker.com/compose/compose-file/compose-file-v3/
    version: "3"
    services:
        flask:
            build: . # текущая папка

test 1. terminal
    docker-compose build # подготовка-строительство контейнера
    docker-compose up # запуск контейнера
        докер запускается и сразу гасится, т.к. никаких действий мы ему не прописали.

3. в файл docker-compose.yml прописываем любую команду, чтобы контейнер ее выполнил
    flask:
        build: .
        command: python -V # показать версию python

4. создаем hello world из flask
    https://flask.palletsprojects.com/en/1.1.x/quickstart/
    - создать файл hello.py # название любое. рабочий вариант например run_server.py  
        from flask import Flask
        app = Flask(__name__)

        @app.route('/')
        def hello_world():
            return 'Hello, World!'
    - для запуска flask в докере нужно создать системную переменную и запустить ее как команду вdocker-compose.yml
        command: flask run --host=0.0.0.0 # del python -V
        environment:
            - FLASK_APP=hello.py
    - для запуска flask из docker-compose необходимо в Dockerfile прописать установку этой библиотеки
        RUN pip install flask
    и в Dockerfile прописать копирование созданный файл в докер
        COPY . .  # содержимое всей текущей локальной директории в текущую директорию докера

test2 после изменения файла Dockerfile необходимо заново построить конейнер и потом запустить
    docker-compose build
    docker-compose up
    или выполнить одной командой
    docker-compose up --build
    результат: Running on http://127.0.0.1:5000/ - но пока еще не рабочая

5. прописать порты в docker-compose.yml для того, чтобы flask запускался с докера, а не с локальной машины
    environment:
      - FLASK_APP=hello.py
    ports:
      - '5000:5000' # соответствие порта локальной машины и порта докера

test3
    ctrl+C # останавливаем сервер
    docker-compose up # запускаем сервер заново
    результат: в браузере по адресу http://0.0.0.0:5000/ видим hello, World!

6. для онлайн обновления изменений на странице сайта через докер производимых на локальной машине
    - docker exec -it <mycontainer> bash - вход внутрь откружения докера для проверки соответствий содержимого файлов на докере и на локальной машине. 
    результат: вход в среду докера с обычным bash
    - обновление в файле появляется только при перестроении/build контейнера, но это очень не удобно
    - создать на докере отдельную папку для проекта
    COPY . /app # в Dockerfile прописываем папку докера при копировании
    WORKDIR /app # в Dockerfile прописываем, что при запуске заходить сразу в эту папку - рабочая директория
    - прописать volumes
    volumes:
      - ./:/app # в docker-compose.yml
    - добавляем системную переменную в файл docker-compose.yml
        environment:
      - FLASK_APP=hello.py
      - FLASK_DEBUG=1

test4
    ctrl+C # останавливаем сервер
    docker-compose up --build # запускаем сервер заново с новым сборкой
    результат: при изменении файла hello.py на локальной машине без перезапуска докера видим изменения в браузере докера

7. создание сервера Gunicorn для среды докера - сервер сильно тормозит озапуск браузера. ОТКЛЮЧАЮ
    - меняем команду запуска
        # command: flask run --host=0.0.0.0
        command: gunicorn -w 4 -b 0.0.0.0:5000 hello:app
    - добавляем gunicorn с список устанавливаемых библиотек в файле Dockerfile
        RUN pip install flask gunicorn
    результат: запускается flask_1  | [2021-04-02 11:32:34 +0000] [1] [INFO] Starting gunicorn 20.1.0 с 4 запущеными воркерами
    - для тестового сайта это лишнее меняем команду отменив запуски воркеров
        # command: gunicorn -w 4 -b 0.0.0.0:5000 hello:app
        command: gunicorn -b 0.0.0.0:5000 hello:app
    - автообновление сайта на докере из локалки отвалилось
    - для автообновления сайта на докере
        # command: gunicorn -b 0.0.0.0:5000 hello:app --reload
        command: gunicorn -b 0.0.0.0:5000 hello:app

8. для отладки вывод print в терминал
    - добавляем системную переменную
        environment:
      - PYTHONBUFFERED=True

9. изменение порта при запуске докера
    environment:
      - FLASK_RUN_PORT=8181

10. GET - запросы
    - добавлена функция get запроса в hello.py
        @app.route('/user/<username>')
        def show_user(username):
            return f'User {username}'

Command:

docker-compose build # подготовка-строительство контейнера
docker-compose up # запуск контейнера
docker-compose up --build # запуск и подготовка контейнера
ctrl+C # останавливаем сервер
ctrl+C 2 раза # убиваем сервер
docker exec -it <mycontainer> bash # вход внутрь откружения докера
exit # выход из докера
docker images # просмотр Docker-образов
docker rmi <image> # удалить Docker-образ
docker rmi -f <image> # принудительно удалить Docker-образ
docker image prune -a -f # удалить все неиспользуемые Docker-образы
docker rmi -f $(docker images -q) # принудительно удалить все Docker-образы
остановить и удалить все докеры, образы, связи, сетевые соединения
docker stop $(docker ps -qa) && docker rm $(docker ps -qa) && docker rmi -f $(docker images -qa ) && docker volume rm $(docker volume ls -q) && docker network rm $(docker network ls -q)

<!-- POST запрос через терминал -->
curl --header 'Content-Type: application/json' \
    --request POST \
    --data '{"flower":"1,2,3,8"}' \
    http://localhost:8181/iris_post

ERROR: Creating network "docker_compose_flask_catboost_vpcbr" with driver "bridge"